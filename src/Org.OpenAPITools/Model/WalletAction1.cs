// <auto-generated>
/*
 * Rise.ai API Documentation
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Org.OpenAPITools.Client;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// The created WalletAction.
    /// </summary>
    public partial class WalletAction1 : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="WalletAction1" /> class.
        /// </summary>
        /// <param name="id">WalletAction ID.</param>
        /// <param name="revision">Represents the current state of an item. Each time the item is modified, its &#x60;revision&#x60; changes. For an update operation to succeed, you MUST pass the latest revision.</param>
        /// <param name="createdDate">Represents the time this WalletAction was created.</param>
        /// <param name="updatedDate">Represents the time this WalletAction was last updated.</param>
        /// <param name="startDate">Represents the time at which the WalletAction&#39;s amount will be added to the account. Defaults to immediately.</param>
        /// <param name="expirationDate">Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.</param>
        /// <param name="disableDate">Represents the time at which the WalletAction was manually disabled, if applicable.</param>
        /// <param name="amount">The amount to be added to the Wallet.</param>
        /// <param name="note">Free text comment regarding the WalletAction context (**Deprecated**: Use &#x60;note&#x60; instead.)</param>
        /// <param name="type">Indicates the kind of the specific WalletAction (**Deprecated**)</param>
        /// <param name="walletActionStarted">walletActionStarted</param>
        /// <param name="walletActionEnded">walletActionEnded</param>
        /// <param name="status">The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.</param>
        /// <param name="source">source</param>
        /// <param name="notifications">notifications</param>
        /// <param name="liability">Indicates whether the WalletAction is a liability. The default is false.</param>
        /// <param name="storeCreditContext">storeCreditContext</param>
        /// <param name="externalEvent">externalEvent</param>
        /// <param name="walletId">ID of the wallet to which the WalletAction belongs.</param>
        /// <param name="idempotencyKey">Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.</param>
        [JsonConstructor]
        public WalletAction1(Option<string?> id = default, Option<string?> revision = default, Option<DateTime?> createdDate = default, Option<DateTime?> updatedDate = default, Option<DateTime?> startDate = default, Option<DateTime?> expirationDate = default, Option<DateTime?> disableDate = default, Option<string?> amount = default, Option<string?> note = default, Option<TypeEnum?> type = default, Option<WalletActionExecutionDetails1?> walletActionStarted = default, Option<WalletActionExecutionDetails2?> walletActionEnded = default, Option<StatusEnum?> status = default, Option<ActionInitiator2?> source = default, Option<Notifications1?> notifications = default, Option<bool?> liability = default, Option<StoreCreditContext1?> storeCreditContext = default, Option<ExternalEvent2?> externalEvent = default, Option<string?> walletId = default, Option<string?> idempotencyKey = default)
        {
            IdOption = id;
            RevisionOption = revision;
            CreatedDateOption = createdDate;
            UpdatedDateOption = updatedDate;
            StartDateOption = startDate;
            ExpirationDateOption = expirationDate;
            DisableDateOption = disableDate;
            AmountOption = amount;
            NoteOption = note;
            TypeOption = type;
            WalletActionStartedOption = walletActionStarted;
            WalletActionEndedOption = walletActionEnded;
            StatusOption = status;
            SourceOption = source;
            NotificationsOption = notifications;
            LiabilityOption = liability;
            StoreCreditContextOption = storeCreditContext;
            ExternalEventOption = externalEvent;
            WalletIdOption = walletId;
            IdempotencyKeyOption = idempotencyKey;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Indicates the kind of the specific WalletAction (**Deprecated**)
        /// </summary>
        /// <value>Indicates the kind of the specific WalletAction (**Deprecated**)</value>
        public enum TypeEnum
        {
            /// <summary>
            /// Enum UNKNOWN for value: UNKNOWN
            /// </summary>
            UNKNOWN,

            /// <summary>
            /// Enum REWARD for value: REWARD
            /// </summary>
            REWARD,

            /// <summary>
            /// Enum REFUND for value: REFUND
            /// </summary>
            REFUND
        }

        /// <summary>
        /// Returns a <see cref="TypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static TypeEnum TypeEnumFromString(string value)
        {
            if (value.Equals("UNKNOWN"))
                return TypeEnum.UNKNOWN;

            if (value.Equals("REWARD"))
                return TypeEnum.REWARD;

            if (value.Equals("REFUND"))
                return TypeEnum.REFUND;

            throw new NotImplementedException($"Could not convert value to type TypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="TypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static TypeEnum? TypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("UNKNOWN"))
                return TypeEnum.UNKNOWN;

            if (value.Equals("REWARD"))
                return TypeEnum.REWARD;

            if (value.Equals("REFUND"))
                return TypeEnum.REFUND;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="TypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string TypeEnumToJsonValue(TypeEnum? value)
        {
            if (value == TypeEnum.UNKNOWN)
                return "UNKNOWN";

            if (value == TypeEnum.REWARD)
                return "REWARD";

            if (value == TypeEnum.REFUND)
                return "REFUND";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of Type
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<TypeEnum?> TypeOption { get; private set; }

        /// <summary>
        /// Indicates the kind of the specific WalletAction (**Deprecated**)
        /// </summary>
        /// <value>Indicates the kind of the specific WalletAction (**Deprecated**)</value>
        [JsonPropertyName("type")]
        [Obsolete]
        public TypeEnum? Type { get { return this.TypeOption; } set { this.TypeOption = new(value); } }

        /// <summary>
        /// The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
        /// </summary>
        /// <value>The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.</value>
        public enum StatusEnum
        {
            /// <summary>
            /// Enum PENDING for value: PENDING
            /// </summary>
            PENDING = 1,

            /// <summary>
            /// Enum ACTIVE for value: ACTIVE
            /// </summary>
            ACTIVE = 2,

            /// <summary>
            /// Enum DISABLED for value: DISABLED
            /// </summary>
            DISABLED = 3,

            /// <summary>
            /// Enum EXPIRED for value: EXPIRED
            /// </summary>
            EXPIRED = 4,

            /// <summary>
            /// Enum FAILED for value: FAILED
            /// </summary>
            FAILED = 5
        }

        /// <summary>
        /// Returns a <see cref="StatusEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static StatusEnum StatusEnumFromString(string value)
        {
            if (value.Equals("PENDING"))
                return StatusEnum.PENDING;

            if (value.Equals("ACTIVE"))
                return StatusEnum.ACTIVE;

            if (value.Equals("DISABLED"))
                return StatusEnum.DISABLED;

            if (value.Equals("EXPIRED"))
                return StatusEnum.EXPIRED;

            if (value.Equals("FAILED"))
                return StatusEnum.FAILED;

            throw new NotImplementedException($"Could not convert value to type StatusEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="StatusEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static StatusEnum? StatusEnumFromStringOrDefault(string value)
        {
            if (value.Equals("PENDING"))
                return StatusEnum.PENDING;

            if (value.Equals("ACTIVE"))
                return StatusEnum.ACTIVE;

            if (value.Equals("DISABLED"))
                return StatusEnum.DISABLED;

            if (value.Equals("EXPIRED"))
                return StatusEnum.EXPIRED;

            if (value.Equals("FAILED"))
                return StatusEnum.FAILED;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="StatusEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string StatusEnumToJsonValue(StatusEnum? value)
        {
            if (value == StatusEnum.PENDING)
                return "PENDING";

            if (value == StatusEnum.ACTIVE)
                return "ACTIVE";

            if (value == StatusEnum.DISABLED)
                return "DISABLED";

            if (value == StatusEnum.EXPIRED)
                return "EXPIRED";

            if (value == StatusEnum.FAILED)
                return "FAILED";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of Status
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StatusEnum?> StatusOption { get; }

        /// <summary>
        /// The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.
        /// </summary>
        /// <value>The current status of the WalletAction. Set to PENDING when the WalletAction is created and updated to ACTIVE when the amount is added to the wallet.</value>
        [JsonPropertyName("status")]
        public StatusEnum? Status { get { return this.StatusOption; } }

        /// <summary>
        /// Used to track the state of Id
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> IdOption { get; }

        /// <summary>
        /// WalletAction ID.
        /// </summary>
        /// <value>WalletAction ID.</value>
        [JsonPropertyName("id")]
        public string? Id { get { return this.IdOption; } }

        /// <summary>
        /// Used to track the state of Revision
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> RevisionOption { get; }

        /// <summary>
        /// Represents the current state of an item. Each time the item is modified, its &#x60;revision&#x60; changes. For an update operation to succeed, you MUST pass the latest revision.
        /// </summary>
        /// <value>Represents the current state of an item. Each time the item is modified, its &#x60;revision&#x60; changes. For an update operation to succeed, you MUST pass the latest revision.</value>
        [JsonPropertyName("revision")]
        public string? Revision { get { return this.RevisionOption; } }

        /// <summary>
        /// Used to track the state of CreatedDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> CreatedDateOption { get; }

        /// <summary>
        /// Represents the time this WalletAction was created.
        /// </summary>
        /// <value>Represents the time this WalletAction was created.</value>
        [JsonPropertyName("createdDate")]
        public DateTime? CreatedDate { get { return this.CreatedDateOption; } }

        /// <summary>
        /// Used to track the state of UpdatedDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> UpdatedDateOption { get; }

        /// <summary>
        /// Represents the time this WalletAction was last updated.
        /// </summary>
        /// <value>Represents the time this WalletAction was last updated.</value>
        [JsonPropertyName("updatedDate")]
        public DateTime? UpdatedDate { get { return this.UpdatedDateOption; } }

        /// <summary>
        /// Used to track the state of StartDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> StartDateOption { get; private set; }

        /// <summary>
        /// Represents the time at which the WalletAction&#39;s amount will be added to the account. Defaults to immediately.
        /// </summary>
        /// <value>Represents the time at which the WalletAction&#39;s amount will be added to the account. Defaults to immediately.</value>
        [JsonPropertyName("startDate")]
        public DateTime? StartDate { get { return this.StartDateOption; } set { this.StartDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of ExpirationDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> ExpirationDateOption { get; private set; }

        /// <summary>
        /// Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.
        /// </summary>
        /// <value>Represents the time at which the unused balance of the WalletAction will be deducted from the account. Defaults to never.</value>
        [JsonPropertyName("expirationDate")]
        public DateTime? ExpirationDate { get { return this.ExpirationDateOption; } set { this.ExpirationDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of DisableDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> DisableDateOption { get; }

        /// <summary>
        /// Represents the time at which the WalletAction was manually disabled, if applicable.
        /// </summary>
        /// <value>Represents the time at which the WalletAction was manually disabled, if applicable.</value>
        [JsonPropertyName("disableDate")]
        public DateTime? DisableDate { get { return this.DisableDateOption; } }

        /// <summary>
        /// Used to track the state of Amount
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> AmountOption { get; private set; }

        /// <summary>
        /// The amount to be added to the Wallet.
        /// </summary>
        /// <value>The amount to be added to the Wallet.</value>
        [JsonPropertyName("amount")]
        public string? Amount { get { return this.AmountOption; } set { this.AmountOption = new(value); } }

        /// <summary>
        /// Used to track the state of Note
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> NoteOption { get; private set; }

        /// <summary>
        /// Free text comment regarding the WalletAction context (**Deprecated**: Use &#x60;note&#x60; instead.)
        /// </summary>
        /// <value>Free text comment regarding the WalletAction context (**Deprecated**: Use &#x60;note&#x60; instead.)</value>
        [JsonPropertyName("note")]
        [Obsolete]
        public string? Note { get { return this.NoteOption; } set { this.NoteOption = new(value); } }

        /// <summary>
        /// Used to track the state of WalletActionStarted
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<WalletActionExecutionDetails1?> WalletActionStartedOption { get; private set; }

        /// <summary>
        /// Gets or Sets WalletActionStarted
        /// </summary>
        [JsonPropertyName("walletActionStarted")]
        public WalletActionExecutionDetails1? WalletActionStarted { get { return this.WalletActionStartedOption; } set { this.WalletActionStartedOption = new(value); } }

        /// <summary>
        /// Used to track the state of WalletActionEnded
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<WalletActionExecutionDetails2?> WalletActionEndedOption { get; private set; }

        /// <summary>
        /// Gets or Sets WalletActionEnded
        /// </summary>
        [JsonPropertyName("walletActionEnded")]
        public WalletActionExecutionDetails2? WalletActionEnded { get { return this.WalletActionEndedOption; } set { this.WalletActionEndedOption = new(value); } }

        /// <summary>
        /// Used to track the state of Source
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ActionInitiator2?> SourceOption { get; private set; }

        /// <summary>
        /// Gets or Sets Source
        /// </summary>
        [JsonPropertyName("source")]
        public ActionInitiator2? Source { get { return this.SourceOption; } set { this.SourceOption = new(value); } }

        /// <summary>
        /// Used to track the state of Notifications
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Notifications1?> NotificationsOption { get; private set; }

        /// <summary>
        /// Gets or Sets Notifications
        /// </summary>
        [JsonPropertyName("notifications")]
        public Notifications1? Notifications { get { return this.NotificationsOption; } set { this.NotificationsOption = new(value); } }

        /// <summary>
        /// Used to track the state of Liability
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> LiabilityOption { get; private set; }

        /// <summary>
        /// Indicates whether the WalletAction is a liability. The default is false.
        /// </summary>
        /// <value>Indicates whether the WalletAction is a liability. The default is false.</value>
        [JsonPropertyName("liability")]
        public bool? Liability { get { return this.LiabilityOption; } set { this.LiabilityOption = new(value); } }

        /// <summary>
        /// Used to track the state of StoreCreditContext
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<StoreCreditContext1?> StoreCreditContextOption { get; private set; }

        /// <summary>
        /// Gets or Sets StoreCreditContext
        /// </summary>
        [JsonPropertyName("storeCreditContext")]
        public StoreCreditContext1? StoreCreditContext { get { return this.StoreCreditContextOption; } set { this.StoreCreditContextOption = new(value); } }

        /// <summary>
        /// Used to track the state of ExternalEvent
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<ExternalEvent2?> ExternalEventOption { get; private set; }

        /// <summary>
        /// Gets or Sets ExternalEvent
        /// </summary>
        [JsonPropertyName("externalEvent")]
        public ExternalEvent2? ExternalEvent { get { return this.ExternalEventOption; } set { this.ExternalEventOption = new(value); } }

        /// <summary>
        /// Used to track the state of WalletId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> WalletIdOption { get; private set; }

        /// <summary>
        /// ID of the wallet to which the WalletAction belongs.
        /// </summary>
        /// <value>ID of the wallet to which the WalletAction belongs.</value>
        [JsonPropertyName("walletId")]
        public string? WalletId { get { return this.WalletIdOption; } set { this.WalletIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of IdempotencyKey
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> IdempotencyKeyOption { get; private set; }

        /// <summary>
        /// Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.
        /// </summary>
        /// <value>Unique key to identify the WalletAction, used to prevent duplicate WalletActions from being created in case of retries or network issues. The key should be unique for each WalletAction and should not be reused.</value>
        [JsonPropertyName("idempotencyKey")]
        public string? IdempotencyKey { get { return this.IdempotencyKeyOption; } set { this.IdempotencyKeyOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class WalletAction1 {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Revision: ").Append(Revision).Append("\n");
            sb.Append("  CreatedDate: ").Append(CreatedDate).Append("\n");
            sb.Append("  UpdatedDate: ").Append(UpdatedDate).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  ExpirationDate: ").Append(ExpirationDate).Append("\n");
            sb.Append("  DisableDate: ").Append(DisableDate).Append("\n");
            sb.Append("  Amount: ").Append(Amount).Append("\n");
            sb.Append("  Note: ").Append(Note).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  WalletActionStarted: ").Append(WalletActionStarted).Append("\n");
            sb.Append("  WalletActionEnded: ").Append(WalletActionEnded).Append("\n");
            sb.Append("  Status: ").Append(Status).Append("\n");
            sb.Append("  Source: ").Append(Source).Append("\n");
            sb.Append("  Notifications: ").Append(Notifications).Append("\n");
            sb.Append("  Liability: ").Append(Liability).Append("\n");
            sb.Append("  StoreCreditContext: ").Append(StoreCreditContext).Append("\n");
            sb.Append("  ExternalEvent: ").Append(ExternalEvent).Append("\n");
            sb.Append("  WalletId: ").Append(WalletId).Append("\n");
            sb.Append("  IdempotencyKey: ").Append(IdempotencyKey).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Note (string) maxLength
            if (this.Note != null && this.Note.Length > 550)
            {
                yield return new ValidationResult("Invalid value for Note, length must be less than 550.", new [] { "Note" });
            }

            // IdempotencyKey (string) maxLength
            if (this.IdempotencyKey != null && this.IdempotencyKey.Length > 100)
            {
                yield return new ValidationResult("Invalid value for IdempotencyKey, length must be less than 100.", new [] { "IdempotencyKey" });
            }

            // IdempotencyKey (string) minLength
            if (this.IdempotencyKey != null && this.IdempotencyKey.Length < 1)
            {
                yield return new ValidationResult("Invalid value for IdempotencyKey, length must be greater than 1.", new [] { "IdempotencyKey" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="WalletAction1" />
    /// </summary>
    public class WalletAction1JsonConverter : JsonConverter<WalletAction1>
    {
        /// <summary>
        /// The format to use to serialize CreatedDate
        /// </summary>
        public static string CreatedDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedDate
        /// </summary>
        public static string UpdatedDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize StartDate
        /// </summary>
        public static string StartDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize ExpirationDate
        /// </summary>
        public static string ExpirationDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize DisableDate
        /// </summary>
        public static string DisableDateFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="WalletAction1" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override WalletAction1 Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> id = default;
            Option<string?> revision = default;
            Option<DateTime?> createdDate = default;
            Option<DateTime?> updatedDate = default;
            Option<DateTime?> startDate = default;
            Option<DateTime?> expirationDate = default;
            Option<DateTime?> disableDate = default;
            Option<string?> amount = default;
            Option<string?> note = default;
            Option<WalletAction1.TypeEnum?> type = default;
            Option<WalletActionExecutionDetails1?> walletActionStarted = default;
            Option<WalletActionExecutionDetails2?> walletActionEnded = default;
            Option<WalletAction1.StatusEnum?> status = default;
            Option<ActionInitiator2?> source = default;
            Option<Notifications1?> notifications = default;
            Option<bool?> liability = default;
            Option<StoreCreditContext1?> storeCreditContext = default;
            Option<ExternalEvent2?> externalEvent = default;
            Option<string?> walletId = default;
            Option<string?> idempotencyKey = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "id":
                            id = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "revision":
                            revision = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "createdDate":
                            createdDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "updatedDate":
                            updatedDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "startDate":
                            startDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "expirationDate":
                            expirationDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "disableDate":
                            disableDate = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "amount":
                            amount = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "note":
                            note = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "type":
                            string? typeRawValue = utf8JsonReader.GetString();
                            if (typeRawValue != null)
                                type = new Option<WalletAction1.TypeEnum?>(WalletAction1.TypeEnumFromStringOrDefault(typeRawValue));
                            break;
                        case "walletActionStarted":
                            walletActionStarted = new Option<WalletActionExecutionDetails1?>(JsonSerializer.Deserialize<WalletActionExecutionDetails1>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "walletActionEnded":
                            walletActionEnded = new Option<WalletActionExecutionDetails2?>(JsonSerializer.Deserialize<WalletActionExecutionDetails2>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "status":
                            string? statusRawValue = utf8JsonReader.GetString();
                            if (statusRawValue != null)
                                status = new Option<WalletAction1.StatusEnum?>(WalletAction1.StatusEnumFromStringOrDefault(statusRawValue));
                            break;
                        case "source":
                            source = new Option<ActionInitiator2?>(JsonSerializer.Deserialize<ActionInitiator2>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "notifications":
                            notifications = new Option<Notifications1?>(JsonSerializer.Deserialize<Notifications1>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "liability":
                            liability = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "storeCreditContext":
                            storeCreditContext = new Option<StoreCreditContext1?>(JsonSerializer.Deserialize<StoreCreditContext1>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "externalEvent":
                            externalEvent = new Option<ExternalEvent2?>(JsonSerializer.Deserialize<ExternalEvent2>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "walletId":
                            walletId = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "idempotencyKey":
                            idempotencyKey = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class WalletAction1.");

            if (revision.IsSet && revision.Value == null)
                throw new ArgumentNullException(nameof(revision), "Property is not nullable for class WalletAction1.");

            if (createdDate.IsSet && createdDate.Value == null)
                throw new ArgumentNullException(nameof(createdDate), "Property is not nullable for class WalletAction1.");

            if (updatedDate.IsSet && updatedDate.Value == null)
                throw new ArgumentNullException(nameof(updatedDate), "Property is not nullable for class WalletAction1.");

            if (startDate.IsSet && startDate.Value == null)
                throw new ArgumentNullException(nameof(startDate), "Property is not nullable for class WalletAction1.");

            if (expirationDate.IsSet && expirationDate.Value == null)
                throw new ArgumentNullException(nameof(expirationDate), "Property is not nullable for class WalletAction1.");

            if (disableDate.IsSet && disableDate.Value == null)
                throw new ArgumentNullException(nameof(disableDate), "Property is not nullable for class WalletAction1.");

            if (amount.IsSet && amount.Value == null)
                throw new ArgumentNullException(nameof(amount), "Property is not nullable for class WalletAction1.");

            if (note.IsSet && note.Value == null)
                throw new ArgumentNullException(nameof(note), "Property is not nullable for class WalletAction1.");

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type), "Property is not nullable for class WalletAction1.");

            if (walletActionStarted.IsSet && walletActionStarted.Value == null)
                throw new ArgumentNullException(nameof(walletActionStarted), "Property is not nullable for class WalletAction1.");

            if (walletActionEnded.IsSet && walletActionEnded.Value == null)
                throw new ArgumentNullException(nameof(walletActionEnded), "Property is not nullable for class WalletAction1.");

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status), "Property is not nullable for class WalletAction1.");

            if (source.IsSet && source.Value == null)
                throw new ArgumentNullException(nameof(source), "Property is not nullable for class WalletAction1.");

            if (notifications.IsSet && notifications.Value == null)
                throw new ArgumentNullException(nameof(notifications), "Property is not nullable for class WalletAction1.");

            if (liability.IsSet && liability.Value == null)
                throw new ArgumentNullException(nameof(liability), "Property is not nullable for class WalletAction1.");

            if (storeCreditContext.IsSet && storeCreditContext.Value == null)
                throw new ArgumentNullException(nameof(storeCreditContext), "Property is not nullable for class WalletAction1.");

            if (externalEvent.IsSet && externalEvent.Value == null)
                throw new ArgumentNullException(nameof(externalEvent), "Property is not nullable for class WalletAction1.");

            if (walletId.IsSet && walletId.Value == null)
                throw new ArgumentNullException(nameof(walletId), "Property is not nullable for class WalletAction1.");

            if (idempotencyKey.IsSet && idempotencyKey.Value == null)
                throw new ArgumentNullException(nameof(idempotencyKey), "Property is not nullable for class WalletAction1.");

            return new WalletAction1(id, revision, createdDate, updatedDate, startDate, expirationDate, disableDate, amount, note, type, walletActionStarted, walletActionEnded, status, source, notifications, liability, storeCreditContext, externalEvent, walletId, idempotencyKey);
        }

        /// <summary>
        /// Serializes a <see cref="WalletAction1" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="walletAction1"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, WalletAction1 walletAction1, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, walletAction1, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="WalletAction1" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="walletAction1"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, WalletAction1 walletAction1, JsonSerializerOptions jsonSerializerOptions)
        {
            if (walletAction1.IdOption.IsSet && walletAction1.Id == null)
                throw new ArgumentNullException(nameof(walletAction1.Id), "Property is required for class WalletAction1.");

            if (walletAction1.RevisionOption.IsSet && walletAction1.Revision == null)
                throw new ArgumentNullException(nameof(walletAction1.Revision), "Property is required for class WalletAction1.");

            if (walletAction1.AmountOption.IsSet && walletAction1.Amount == null)
                throw new ArgumentNullException(nameof(walletAction1.Amount), "Property is required for class WalletAction1.");

            if (walletAction1.NoteOption.IsSet && walletAction1.Note == null)
                throw new ArgumentNullException(nameof(walletAction1.Note), "Property is required for class WalletAction1.");

            if (walletAction1.WalletActionStartedOption.IsSet && walletAction1.WalletActionStarted == null)
                throw new ArgumentNullException(nameof(walletAction1.WalletActionStarted), "Property is required for class WalletAction1.");

            if (walletAction1.WalletActionEndedOption.IsSet && walletAction1.WalletActionEnded == null)
                throw new ArgumentNullException(nameof(walletAction1.WalletActionEnded), "Property is required for class WalletAction1.");

            if (walletAction1.SourceOption.IsSet && walletAction1.Source == null)
                throw new ArgumentNullException(nameof(walletAction1.Source), "Property is required for class WalletAction1.");

            if (walletAction1.NotificationsOption.IsSet && walletAction1.Notifications == null)
                throw new ArgumentNullException(nameof(walletAction1.Notifications), "Property is required for class WalletAction1.");

            if (walletAction1.StoreCreditContextOption.IsSet && walletAction1.StoreCreditContext == null)
                throw new ArgumentNullException(nameof(walletAction1.StoreCreditContext), "Property is required for class WalletAction1.");

            if (walletAction1.ExternalEventOption.IsSet && walletAction1.ExternalEvent == null)
                throw new ArgumentNullException(nameof(walletAction1.ExternalEvent), "Property is required for class WalletAction1.");

            if (walletAction1.WalletIdOption.IsSet && walletAction1.WalletId == null)
                throw new ArgumentNullException(nameof(walletAction1.WalletId), "Property is required for class WalletAction1.");

            if (walletAction1.IdempotencyKeyOption.IsSet && walletAction1.IdempotencyKey == null)
                throw new ArgumentNullException(nameof(walletAction1.IdempotencyKey), "Property is required for class WalletAction1.");

            if (walletAction1.IdOption.IsSet)
                writer.WriteString("id", walletAction1.Id);

            if (walletAction1.RevisionOption.IsSet)
                writer.WriteString("revision", walletAction1.Revision);

            if (walletAction1.CreatedDateOption.IsSet)
                writer.WriteString("createdDate", walletAction1.CreatedDateOption.Value!.Value.ToString(CreatedDateFormat));

            if (walletAction1.UpdatedDateOption.IsSet)
                writer.WriteString("updatedDate", walletAction1.UpdatedDateOption.Value!.Value.ToString(UpdatedDateFormat));

            if (walletAction1.StartDateOption.IsSet)
                writer.WriteString("startDate", walletAction1.StartDateOption.Value!.Value.ToString(StartDateFormat));

            if (walletAction1.ExpirationDateOption.IsSet)
                writer.WriteString("expirationDate", walletAction1.ExpirationDateOption.Value!.Value.ToString(ExpirationDateFormat));

            if (walletAction1.DisableDateOption.IsSet)
                writer.WriteString("disableDate", walletAction1.DisableDateOption.Value!.Value.ToString(DisableDateFormat));

            if (walletAction1.AmountOption.IsSet)
                writer.WriteString("amount", walletAction1.Amount);

            if (walletAction1.NoteOption.IsSet)
                writer.WriteString("note", walletAction1.Note);

            var typeRawValue = WalletAction1.TypeEnumToJsonValue(walletAction1.TypeOption.Value!.Value);
            writer.WriteString("type", typeRawValue);
            if (walletAction1.WalletActionStartedOption.IsSet)
            {
                writer.WritePropertyName("walletActionStarted");
                JsonSerializer.Serialize(writer, walletAction1.WalletActionStarted, jsonSerializerOptions);
            }
            if (walletAction1.WalletActionEndedOption.IsSet)
            {
                writer.WritePropertyName("walletActionEnded");
                JsonSerializer.Serialize(writer, walletAction1.WalletActionEnded, jsonSerializerOptions);
            }
            var statusRawValue = WalletAction1.StatusEnumToJsonValue(walletAction1.StatusOption.Value!.Value);
            writer.WriteString("status", statusRawValue);
            if (walletAction1.SourceOption.IsSet)
            {
                writer.WritePropertyName("source");
                JsonSerializer.Serialize(writer, walletAction1.Source, jsonSerializerOptions);
            }
            if (walletAction1.NotificationsOption.IsSet)
            {
                writer.WritePropertyName("notifications");
                JsonSerializer.Serialize(writer, walletAction1.Notifications, jsonSerializerOptions);
            }
            if (walletAction1.LiabilityOption.IsSet)
                writer.WriteBoolean("liability", walletAction1.LiabilityOption.Value!.Value);

            if (walletAction1.StoreCreditContextOption.IsSet)
            {
                writer.WritePropertyName("storeCreditContext");
                JsonSerializer.Serialize(writer, walletAction1.StoreCreditContext, jsonSerializerOptions);
            }
            if (walletAction1.ExternalEventOption.IsSet)
            {
                writer.WritePropertyName("externalEvent");
                JsonSerializer.Serialize(writer, walletAction1.ExternalEvent, jsonSerializerOptions);
            }
            if (walletAction1.WalletIdOption.IsSet)
                writer.WriteString("walletId", walletAction1.WalletId);

            if (walletAction1.IdempotencyKeyOption.IsSet)
                writer.WriteString("idempotencyKey", walletAction1.IdempotencyKey);
        }
    }
}
